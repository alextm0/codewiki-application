"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/vfile-location";
exports.ids = ["vendor-chunks/vfile-location"];
exports.modules = {

/***/ "(ssr)/./node_modules/vfile-location/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/vfile-location/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   location: () => (/* binding */ location)\n/* harmony export */ });\n/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('vfile').Value} Value\n * @typedef {import('unist').Point} UnistPoint\n */ /**\n *\n * @typedef PointLike\n *   unist point, allowed as input.\n * @property {number | null | undefined} [line]\n *   Line.\n * @property {number | null | undefined} [column]\n *   Column.\n * @property {number | null | undefined} [offset]\n *   Offset.\n *\n * @callback ToPoint\n *   Get the line/column based `Point` for `offset` in the bound indices.\n *\n *   Returns `undefined` when given out of bounds input.\n *\n *   Also implemented in Rust in [`wooorm/markdown-rs`][markdown-rs].\n *\n *   [markdown-rs]: https://github.com/wooorm/markdown-rs/blob/main/src/util/location.rs\n * @param {number | null | undefined} [offset]\n *   Something that should be an `offset.\n * @returns {UnistPoint | undefined}\n *   Point, if `offset` is valid and in-bounds input.\n *\n * @callback ToOffset\n *   Get the `offset` from a line/column based `Point` in the bound indices.\n * @param {PointLike | null | undefined} [point]\n *   Something that should be a `point.\n * @returns {number | undefined}\n *   Offset (`number`) or `undefined` for invalid or out of bounds input.\n *\n * @typedef Location\n *   Accessors for index.\n * @property {ToPoint} toPoint\n *   Get the line/column based `Point` for `offset` in the bound indices.\n * @property {ToOffset} toOffset\n *   Get the `offset` from a line/column based `Point` in the bound indices.\n */ const search = /\\r?\\n|\\r/g;\n/**\n * Create an index of the given document to translate between line/column and\n * offset based positional info.\n *\n * Also implemented in Rust in [`wooorm/markdown-rs`][markdown-rs].\n *\n * [markdown-rs]: https://github.com/wooorm/markdown-rs/blob/main/src/util/location.rs\n *\n * @param {VFile | Value} file\n *   File to index.\n * @returns {Location}\n *   Accessors for index.\n */ function location(file) {\n    const value = String(file);\n    /**\n   * List, where each index is a line number (0-based), and each value is the\n   * byte index *after* where the line ends.\n   *\n   * @type {Array<number>}\n   */ const indices = [];\n    search.lastIndex = 0;\n    while(search.test(value)){\n        indices.push(search.lastIndex);\n    }\n    indices.push(value.length + 1);\n    return {\n        toPoint,\n        toOffset\n    };\n    /** @type {ToPoint} */ function toPoint(offset) {\n        let index = -1;\n        if (typeof offset === \"number\" && offset > -1 && offset < indices[indices.length - 1]) {\n            while(++index < indices.length){\n                if (indices[index] > offset) {\n                    return {\n                        line: index + 1,\n                        column: offset - (index > 0 ? indices[index - 1] : 0) + 1,\n                        offset\n                    };\n                }\n            }\n        }\n    }\n    /** @type {ToOffset} */ function toOffset(point) {\n        const line = point && point.line;\n        const column = point && point.column;\n        if (typeof line === \"number\" && typeof column === \"number\" && !Number.isNaN(line) && !Number.isNaN(column) && line - 1 in indices) {\n            const offset = (indices[line - 2] || 0) + column - 1 || 0;\n            if (offset > -1 && offset < indices[indices.length - 1]) {\n                return offset;\n            }\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmZpbGUtbG9jYXRpb24vbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7OztDQUlDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQ0MsR0FFRCxNQUFNQSxTQUFTO0FBRWY7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBU0MsU0FBU0MsSUFBSTtJQUMzQixNQUFNQyxRQUFRQyxPQUFPRjtJQUNyQjs7Ozs7R0FLQyxHQUNELE1BQU1HLFVBQVUsRUFBRTtJQUVsQkwsT0FBT00sU0FBUyxHQUFHO0lBRW5CLE1BQU9OLE9BQU9PLElBQUksQ0FBQ0osT0FBUTtRQUN6QkUsUUFBUUcsSUFBSSxDQUFDUixPQUFPTSxTQUFTO0lBQy9CO0lBRUFELFFBQVFHLElBQUksQ0FBQ0wsTUFBTU0sTUFBTSxHQUFHO0lBRTVCLE9BQU87UUFBQ0M7UUFBU0M7SUFBUTtJQUV6QixvQkFBb0IsR0FDcEIsU0FBU0QsUUFBUUUsTUFBTTtRQUNyQixJQUFJQyxRQUFRLENBQUM7UUFFYixJQUNFLE9BQU9ELFdBQVcsWUFDbEJBLFNBQVMsQ0FBQyxLQUNWQSxTQUFTUCxPQUFPLENBQUNBLFFBQVFJLE1BQU0sR0FBRyxFQUFFLEVBQ3BDO1lBQ0EsTUFBTyxFQUFFSSxRQUFRUixRQUFRSSxNQUFNLENBQUU7Z0JBQy9CLElBQUlKLE9BQU8sQ0FBQ1EsTUFBTSxHQUFHRCxRQUFRO29CQUMzQixPQUFPO3dCQUNMRSxNQUFNRCxRQUFRO3dCQUNkRSxRQUFRSCxTQUFVQyxDQUFBQSxRQUFRLElBQUlSLE9BQU8sQ0FBQ1EsUUFBUSxFQUFFLEdBQUcsS0FBSzt3QkFDeEREO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBRUEscUJBQXFCLEdBQ3JCLFNBQVNELFNBQVNLLEtBQUs7UUFDckIsTUFBTUYsT0FBT0UsU0FBU0EsTUFBTUYsSUFBSTtRQUNoQyxNQUFNQyxTQUFTQyxTQUFTQSxNQUFNRCxNQUFNO1FBRXBDLElBQ0UsT0FBT0QsU0FBUyxZQUNoQixPQUFPQyxXQUFXLFlBQ2xCLENBQUNFLE9BQU9DLEtBQUssQ0FBQ0osU0FDZCxDQUFDRyxPQUFPQyxLQUFLLENBQUNILFdBQ2RELE9BQU8sS0FBS1QsU0FDWjtZQUNBLE1BQU1PLFNBQVMsQ0FBQ1AsT0FBTyxDQUFDUyxPQUFPLEVBQUUsSUFBSSxLQUFLQyxTQUFTLEtBQUs7WUFFeEQsSUFBSUgsU0FBUyxDQUFDLEtBQUtBLFNBQVNQLE9BQU8sQ0FBQ0EsUUFBUUksTUFBTSxHQUFHLEVBQUUsRUFBRTtnQkFDdkQsT0FBT0c7WUFDVDtRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NvZGV3aWtpX25leHQvLi9ub2RlX21vZHVsZXMvdmZpbGUtbG9jYXRpb24vbGliL2luZGV4LmpzPzAyOTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd2ZmlsZScpLlZGaWxlfSBWRmlsZVxuICogQHR5cGVkZWYge2ltcG9ydCgndmZpbGUnKS5WYWx1ZX0gVmFsdWVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0JykuUG9pbnR9IFVuaXN0UG9pbnRcbiAqL1xuXG4vKipcbiAqXG4gKiBAdHlwZWRlZiBQb2ludExpa2VcbiAqICAgdW5pc3QgcG9pbnQsIGFsbG93ZWQgYXMgaW5wdXQuXG4gKiBAcHJvcGVydHkge251bWJlciB8IG51bGwgfCB1bmRlZmluZWR9IFtsaW5lXVxuICogICBMaW5lLlxuICogQHByb3BlcnR5IHtudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSBbY29sdW1uXVxuICogICBDb2x1bW4uXG4gKiBAcHJvcGVydHkge251bWJlciB8IG51bGwgfCB1bmRlZmluZWR9IFtvZmZzZXRdXG4gKiAgIE9mZnNldC5cbiAqXG4gKiBAY2FsbGJhY2sgVG9Qb2ludFxuICogICBHZXQgdGhlIGxpbmUvY29sdW1uIGJhc2VkIGBQb2ludGAgZm9yIGBvZmZzZXRgIGluIHRoZSBib3VuZCBpbmRpY2VzLlxuICpcbiAqICAgUmV0dXJucyBgdW5kZWZpbmVkYCB3aGVuIGdpdmVuIG91dCBvZiBib3VuZHMgaW5wdXQuXG4gKlxuICogICBBbHNvIGltcGxlbWVudGVkIGluIFJ1c3QgaW4gW2B3b29vcm0vbWFya2Rvd24tcnNgXVttYXJrZG93bi1yc10uXG4gKlxuICogICBbbWFya2Rvd24tcnNdOiBodHRwczovL2dpdGh1Yi5jb20vd29vb3JtL21hcmtkb3duLXJzL2Jsb2IvbWFpbi9zcmMvdXRpbC9sb2NhdGlvbi5yc1xuICogQHBhcmFtIHtudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSBbb2Zmc2V0XVxuICogICBTb21ldGhpbmcgdGhhdCBzaG91bGQgYmUgYW4gYG9mZnNldC5cbiAqIEByZXR1cm5zIHtVbmlzdFBvaW50IHwgdW5kZWZpbmVkfVxuICogICBQb2ludCwgaWYgYG9mZnNldGAgaXMgdmFsaWQgYW5kIGluLWJvdW5kcyBpbnB1dC5cbiAqXG4gKiBAY2FsbGJhY2sgVG9PZmZzZXRcbiAqICAgR2V0IHRoZSBgb2Zmc2V0YCBmcm9tIGEgbGluZS9jb2x1bW4gYmFzZWQgYFBvaW50YCBpbiB0aGUgYm91bmQgaW5kaWNlcy5cbiAqIEBwYXJhbSB7UG9pbnRMaWtlIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3BvaW50XVxuICogICBTb21ldGhpbmcgdGhhdCBzaG91bGQgYmUgYSBgcG9pbnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICogICBPZmZzZXQgKGBudW1iZXJgKSBvciBgdW5kZWZpbmVkYCBmb3IgaW52YWxpZCBvciBvdXQgb2YgYm91bmRzIGlucHV0LlxuICpcbiAqIEB0eXBlZGVmIExvY2F0aW9uXG4gKiAgIEFjY2Vzc29ycyBmb3IgaW5kZXguXG4gKiBAcHJvcGVydHkge1RvUG9pbnR9IHRvUG9pbnRcbiAqICAgR2V0IHRoZSBsaW5lL2NvbHVtbiBiYXNlZCBgUG9pbnRgIGZvciBgb2Zmc2V0YCBpbiB0aGUgYm91bmQgaW5kaWNlcy5cbiAqIEBwcm9wZXJ0eSB7VG9PZmZzZXR9IHRvT2Zmc2V0XG4gKiAgIEdldCB0aGUgYG9mZnNldGAgZnJvbSBhIGxpbmUvY29sdW1uIGJhc2VkIGBQb2ludGAgaW4gdGhlIGJvdW5kIGluZGljZXMuXG4gKi9cblxuY29uc3Qgc2VhcmNoID0gL1xccj9cXG58XFxyL2dcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5kZXggb2YgdGhlIGdpdmVuIGRvY3VtZW50IHRvIHRyYW5zbGF0ZSBiZXR3ZWVuIGxpbmUvY29sdW1uIGFuZFxuICogb2Zmc2V0IGJhc2VkIHBvc2l0aW9uYWwgaW5mby5cbiAqXG4gKiBBbHNvIGltcGxlbWVudGVkIGluIFJ1c3QgaW4gW2B3b29vcm0vbWFya2Rvd24tcnNgXVttYXJrZG93bi1yc10uXG4gKlxuICogW21hcmtkb3duLXJzXTogaHR0cHM6Ly9naXRodWIuY29tL3dvb29ybS9tYXJrZG93bi1ycy9ibG9iL21haW4vc3JjL3V0aWwvbG9jYXRpb24ucnNcbiAqXG4gKiBAcGFyYW0ge1ZGaWxlIHwgVmFsdWV9IGZpbGVcbiAqICAgRmlsZSB0byBpbmRleC5cbiAqIEByZXR1cm5zIHtMb2NhdGlvbn1cbiAqICAgQWNjZXNzb3JzIGZvciBpbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvY2F0aW9uKGZpbGUpIHtcbiAgY29uc3QgdmFsdWUgPSBTdHJpbmcoZmlsZSlcbiAgLyoqXG4gICAqIExpc3QsIHdoZXJlIGVhY2ggaW5kZXggaXMgYSBsaW5lIG51bWJlciAoMC1iYXNlZCksIGFuZCBlYWNoIHZhbHVlIGlzIHRoZVxuICAgKiBieXRlIGluZGV4ICphZnRlciogd2hlcmUgdGhlIGxpbmUgZW5kcy5cbiAgICpcbiAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAqL1xuICBjb25zdCBpbmRpY2VzID0gW11cblxuICBzZWFyY2gubGFzdEluZGV4ID0gMFxuXG4gIHdoaWxlIChzZWFyY2gudGVzdCh2YWx1ZSkpIHtcbiAgICBpbmRpY2VzLnB1c2goc2VhcmNoLmxhc3RJbmRleClcbiAgfVxuXG4gIGluZGljZXMucHVzaCh2YWx1ZS5sZW5ndGggKyAxKVxuXG4gIHJldHVybiB7dG9Qb2ludCwgdG9PZmZzZXR9XG5cbiAgLyoqIEB0eXBlIHtUb1BvaW50fSAqL1xuICBmdW5jdGlvbiB0b1BvaW50KG9mZnNldCkge1xuICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJyAmJlxuICAgICAgb2Zmc2V0ID4gLTEgJiZcbiAgICAgIG9mZnNldCA8IGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXVxuICAgICkge1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5kaWNlc1tpbmRleF0gPiBvZmZzZXQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZTogaW5kZXggKyAxLFxuICAgICAgICAgICAgY29sdW1uOiBvZmZzZXQgLSAoaW5kZXggPiAwID8gaW5kaWNlc1tpbmRleCAtIDFdIDogMCkgKyAxLFxuICAgICAgICAgICAgb2Zmc2V0XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEB0eXBlIHtUb09mZnNldH0gKi9cbiAgZnVuY3Rpb24gdG9PZmZzZXQocG9pbnQpIHtcbiAgICBjb25zdCBsaW5lID0gcG9pbnQgJiYgcG9pbnQubGluZVxuICAgIGNvbnN0IGNvbHVtbiA9IHBvaW50ICYmIHBvaW50LmNvbHVtblxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGxpbmUgPT09ICdudW1iZXInICYmXG4gICAgICB0eXBlb2YgY29sdW1uID09PSAnbnVtYmVyJyAmJlxuICAgICAgIU51bWJlci5pc05hTihsaW5lKSAmJlxuICAgICAgIU51bWJlci5pc05hTihjb2x1bW4pICYmXG4gICAgICBsaW5lIC0gMSBpbiBpbmRpY2VzXG4gICAgKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSAoaW5kaWNlc1tsaW5lIC0gMl0gfHwgMCkgKyBjb2x1bW4gLSAxIHx8IDBcblxuICAgICAgaWYgKG9mZnNldCA+IC0xICYmIG9mZnNldCA8IGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSkge1xuICAgICAgICByZXR1cm4gb2Zmc2V0XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsic2VhcmNoIiwibG9jYXRpb24iLCJmaWxlIiwidmFsdWUiLCJTdHJpbmciLCJpbmRpY2VzIiwibGFzdEluZGV4IiwidGVzdCIsInB1c2giLCJsZW5ndGgiLCJ0b1BvaW50IiwidG9PZmZzZXQiLCJvZmZzZXQiLCJpbmRleCIsImxpbmUiLCJjb2x1bW4iLCJwb2ludCIsIk51bWJlciIsImlzTmFOIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/vfile-location/lib/index.js\n");

/***/ })

};
;